<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Math 3D Plotter</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111827;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <!-- N√∫t m·ªü mini form -->
  <div class="fixed bottom-4 right-4 z-20 text-right">
    <button onclick="toggleMiniForm()"
      class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-full shadow-lg">
      ‚öôÔ∏è C√†i ƒê·∫∑t
    </button>

    <!-- Mini form thu g·ªçn -->
    <div id="miniForm"
      class="mt-3 p-4 bg-black/80 backdrop-blur-md rounded-2xl space-y-4 shadow-2xl hidden w-72 max-h-[70vh] overflow-y-auto text-white border border-white/10">
      <!-- Chuy·ªÉn ƒë·ªïi 2D/3D -->
      <div class="flex items-center space-x-2">
        <input type="checkbox" id="toggle2D" onchange="toggle2DMode()"
          class="w-5 h-5 text-blue-500 rounded focus:ring-0">
        <label for="toggle2D" class="text-sm font-semibold">üß≠ Ch·∫ø ƒê·ªô 2D (XY)</label>
      </div>

      <!-- T√πy ch·ªçn hi·ªÉn th·ªã -->
      <div class="space-y-2">
        <button onclick="toggle(axesHelper)"
          class="w-full bg-blue-500 hover:bg-blue-600 transition px-4 py-2 rounded-xl font-semibold">
          üîÅ Hi·ªán/·∫®n Tr·ª•c XYZ
        </button>
        <button onclick="toggle(gridHelper)"
          class="w-full bg-blue-500 hover:bg-blue-600 transition px-4 py-2 rounded-xl font-semibold">
          üî≥ Hi·ªán/·∫®n L∆∞·ªõi
        </button>
        <button onclick="toggle(line)"
          class="w-full bg-blue-500 hover:bg-blue-600 transition px-4 py-2 rounded-xl font-semibold">
          ‚ù§Ô∏è ·∫®n/Hi·ªán ·∫¢nh Tr√°i Tim
        </button>
      </div>

      <!-- C√†i ƒë·∫∑t hi·ªÉn th·ªã -->
      <div class="space-y-3">
        <label class="block text-sm font-semibold">üéöÔ∏è ƒê·ªô Ph√¢n Gi·∫£i</label>
        <input id="resolution" type="range" min="5" max="50" value="25" class="w-full">

        <label class="block text-sm font-semibold mt-2">üí° Ch·∫ø ƒê·ªô √Ånh S√°ng</label>
        <select id="lightMode" onchange="updateLightMode()" class="w-full text-black px-3 py-2 rounded-lg">
          <option value="soft">M·ªÅm</option>
          <option value="strong">M·∫°nh</option>
          <option value="wireframe">Ch·ªâ khung</option>
        </select>

        <!-- T√πy ch·ªânh tr·ª•c -->
        <div class="grid grid-cols-2 gap-3 text-sm font-medium mt-4">
          <label class="flex flex-col">
            X min
            <input id="xMin" type="number" value="-50" class="text-black px-2 py-1 rounded-lg">
          </label>
          <label class="flex flex-col">
            X max
            <input id="xMax" type="number" value="50" class="text-black px-2 py-1 rounded-lg">
          </label>
          <label class="flex flex-col">
            Y min
            <input id="yMin" type="number" value="-50" class="text-black px-2 py-1 rounded-lg">
          </label>
          <label class="flex flex-col">
            Y max
            <input id="yMax" type="number" value="50" class="text-black px-2 py-1 rounded-lg">
          </label>
        </div>
      </div>

      <!-- N√∫t xu·∫•t ·∫£nh -->
      <button onclick="saveImage()"
        class="w-full bg-red-600 hover:bg-red-700 transition px-4 py-2 rounded-xl font-semibold mt-4">
        üì∏ Xu·∫•t ·∫¢nh
      </button>
    </div>
  </div>
  <!-- Menu B·∫≠t/T·∫Øt -->
  <!-- N√∫t 3 g·∫°ch g√≥c tr√°i -->
  <!-- N√∫t 3 g·∫°ch ƒë·ªÉ b·∫≠t menu -->
  <button onclick="toggleMenu()" class="fixed top-4 right-4 z-40 p-2 bg-black/80 text-white rounded-md shadow-md">
    <!-- Bi·ªÉu t∆∞·ª£ng 3 g·∫°ch -->
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"
      stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
    </svg>
  </button>

  <!-- Floating Menu: ·∫©n m·∫∑c ƒë·ªãnh v·ªõi 'hidden' -->
  <div id="floatingMenu"
    class="hidden fixed top-4 right-20 translate-x-1/2 z-30 bg-black/80 text-white rounded-xl px-4 py-3 space-y-2 shadow-xl border border-white/10">
    <div class="flex items-center space-x-2">
      <input type="checkbox" id="toggleShapePanel" onchange="toggleDiv('shapePanel')">
      <label for="toggleShapePanel">üé≤ Kh·ªëi H√¨nh</label>
    </div>
    <div class="flex items-center space-x-2">
      <input type="checkbox" id="toggleFormulaPanel" onchange="toggleDiv('formulaPanel')">
      <label for="toggleFormulaPanel">üìê C√¥ng Th·ª©c</label>
    </div>
    <div class="flex items-center space-x-2">
      <input type="checkbox" id="toggleHistoryPanel" onchange="toggleDiv('historyPanel')">
      <label for="toggleHistoryPanel">üìú L·ªãch S·ª≠</label>
    </div>
  </div>


  <div id="shapePanel"
    class="hidden absolute top-4 left-4 bg-black/60 backdrop-blur-md p-5 rounded-2xl text-white space-y-4 z-10 w-80 max-h-[90vh] overflow-y-auto shadow-2xl border border-white/10">
    <label class="font-semibold">üß± Kh·ªëi H√¨nh 2D/3D</label>
    <select id="primitiveShape" class="w-full text-black px-3 py-2 rounded-lg">
      <option value="none">Ch·ªçn</option>
      <option value="cube">H√¨nh L·∫≠p Ph∆∞∆°ng</option>
      <option value="sphere">H√¨nh C·∫ßu</option>
      <option value="cylinder">H√¨nh Tr·ª•</option>
      <option value="cone">H√¨nh N√≥n</option>
      <option value="circle">H√¨nh Tr√≤n 2D</option>
      <option value="ellipse">Ellipse</option>
      <option value="triangle">Tam Gi√°c 2D</option>
      <option value="pentagon">Ng≈© Gi√°c 2D</option>
      <option value="hexagon">L·ª•c Gi√°c 2D</option>
      <option value="pyramid">H√¨nh Ch√≥p</option>
      <option value="plane">M·∫∑t Ph·∫≥ng</option>
    </select>
    <button onclick="plotPrimitive()"
      class="w-full bg-indigo-600 hover:bg-indigo-700 transition px-4 py-2 rounded-xl font-semibold">‚ûï Th√™m
      Kh·ªëi</button>
  </div>
  <div id="formulaPanel"
    class="hidden absolute top-[200px] left-4 bg-black/60 backdrop-blur-md p-5 rounded-2xl text-white space-y-4 z-10 w-80 max-h-[70vh] overflow-y-auto shadow-2xl border border-white/10">

    <div class="space-y-2">
      <label class="font-semibold">üßÆ C√¥ng Th·ª©c z = f(x, y)</label>
      <input id="inputFormula" type="text" class="w-full text-black px-3 py-2 rounded-lg"
        placeholder="z = sin(x) + cos(y)">
      <select id="mode" class="w-full text-black px-3 py-2 rounded-lg">
        <option value="surface">B·ªÅ M·∫∑t M·ªãn</option>
        <option value="line">D·∫°ng Line</option>
      </select>
      <button onclick="plotSurface()"
        class="w-full bg-green-600 hover:bg-green-700 transition px-4 py-2 rounded-xl font-semibold">üìä V·∫Ω ƒê·ªì
        Th·ªã</button>
    </div>

    <div class="space-y-2">
      <label class="font-semibold">üìà C√¥ng Th·ª©c r = f(Œ∏)</label>
      <input id="polarFormula" type="text" class="w-full text-black px-3 py-2 rounded-lg"
        placeholder="r = 10 * sin(3 * theta)">
      <button onclick="plotPolar()"
        class="w-full bg-purple-600 hover:bg-purple-700 transition px-4 py-2 rounded-xl font-semibold">üìâ V·∫Ω ƒê·ªì Th·ªã
        C·ª±c</button>
    </div>


    <div class="space-y-2">
      <label class="font-semibold">üßÆ C√¥ng Th·ª©c T√πy Ch·ªânh (x, y, z)</label>
      <input id="customX" type="text" class="w-full text-black px-3 py-2 rounded-lg" placeholder="x = ...">
      <input id="customY" type="text" class="w-full text-black px-3 py-2 rounded-lg" placeholder="y = ...">
      <input id="customZ" type="text" class="w-full text-black px-3 py-2 rounded-lg" placeholder="z = ...">
      <div class="grid grid-cols-3 gap-2 text-sm text-white font-medium">
        <label class="flex flex-col">t min <input id="tMin" type="number" value="0"
            class="w-full text-black px-2 py-1 rounded-lg"></label>
        <label class="flex flex-col">t max <input id="tMax" type="number" value="6.28"
            class="w-full text-black px-2 py-1 rounded-lg"></label>
        <label class="flex flex-col">res <input id="tRes" type="number" value="200"
            class="w-full text-black px-2 py-1 rounded-lg"></label>
      </div>
      <button onclick="plotCustom3D()"
        class="w-full bg-yellow-500 hover:bg-yellow-600 transition px-4 py-2 rounded-xl font-semibold">üß™ V·∫Ω H√¨nh T√πy
        Ch·ªânh</button>
    </div>
  </div>

  <div id="historyPanel"
    class="hidden absolute top-4 right-4 bg-gray-900 bg-opacity-70 p-4 rounded-xl text-white space-y-2 z-10 w-64 max-h-96 overflow-y-auto">
    <h2 class="text-lg font-bold mb-2">üßæ L·ªãch S·ª≠ V·∫Ω</h2>
    <ul id="historyList" class="space-y-1 text-sm list-disc list-inside"></ul>
  </div>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(60, 60, 60);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Label renderer
    const labelRenderer = new THREE.CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Helpers
    const axesHelper = new THREE.AxesHelper(50);
    scene.add(axesHelper);

    const gridHelper = new THREE.GridHelper(100, 20);
    scene.add(gridHelper);

    // Light
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(50, 50, 100);
    scene.add(light);

    // Labels
    function createLabel(text, pos, color) {
      const div = document.createElement('div');
      div.textContent = text;
      div.style.color = color;
      div.style.fontWeight = 'bold';
      const label = new THREE.CSS2DObject(div);
      label.position.copy(pos);
      scene.add(label);
    }
    createLabel('.', new THREE.Vector3(0, 0, 0), 'white');
    createLabel('X', new THREE.Vector3(55, 0, 0), 'red');
    createLabel('Y', new THREE.Vector3(0, 55, 0), 'lime');
    createLabel('Z', new THREE.Vector3(0, 0, 55), 'cyan');

    // Heart curve
    function heartFunction3D(t) {
      const s = 2.5;
      const x = s * 16 * Math.pow(Math.sin(t), 3);
      const y = s * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
      const z = s * 4 * Math.sin(2 * t);
      return new THREE.Vector3(x, y, z);
    }
    const heartPoints = Array.from({ length: 500 }, (_, i) => heartFunction3D(i / 500 * Math.PI * 2));
    const heartGeometry = new THREE.BufferGeometry().setFromPoints(heartPoints);
    const line = new THREE.LineLoop(heartGeometry, new THREE.LineBasicMaterial({ color: 0xff66cc }));
    scene.add(line);

    // Toggle visibility
    function toggle(obj) { obj.visible = !obj.visible; }

    // V·∫Ω ƒë·ªì th·ªã m·∫∑t
    let surfaceMesh;
    function plotSurface() {
      const formulaRaw = document.getElementById("inputFormula").value.toLowerCase().replace(/\s+/g, '');
      const mode = document.getElementById("mode").value;
      const resolution = parseInt(document.getElementById("resolution").value);
      const lightMode = document.getElementById("lightMode").value;

      const xMin = parseFloat(document.getElementById("xMin").value);
      const xMax = parseFloat(document.getElementById("xMax").value);
      const yMin = parseFloat(document.getElementById("yMin").value);
      const yMax = parseFloat(document.getElementById("yMax").value);

      let depVar = null;
      const vars = ['x', 'y', 'z'];
      let indepVars = [];

      for (let v of vars) {
        if (formulaRaw.startsWith(v + '=')) {
          depVar = v;
          indepVars = vars.filter(w => w !== v);
          break;
        }
      }

      if (!depVar) {
        alert('C√¥ng th·ª©c ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng x=, y=, ho·∫∑c z=');
        return;
      }

      const exprBody = formulaRaw.split('=')[1];
      let expr;
      try {
        expr = math.compile(exprBody);
      } catch (e) {
        alert('L·ªói c√¥ng th·ª©c: ' + e.message);
        return;
      }

      if (surfaceMesh) scene.remove(surfaceMesh);

      const geometry = new THREE.BufferGeometry();
      const stepX = (xMax - xMin) / resolution;
      const stepY = (yMax - yMin) / resolution;
      const countX = resolution + 1;
      const countY = resolution + 1;
      const points = [];

      for (let i = 0; i <= resolution; i++) {
        const u = xMin + i * stepX;
        for (let j = 0; j <= resolution; j++) {
          const v = yMin + j * stepY;
          let x = 0, y = 0, z = 0;
          const varsObj = {};
          varsObj[indepVars[0]] = u;
          varsObj[indepVars[1]] = v;
          try {
            const result = expr.evaluate(varsObj);
            if (depVar === 'x') {
              x = result; y = u; z = v;
            } else if (depVar === 'y') {
              x = u; y = result; z = v;
            } else {
              x = u; y = v; z = result;
            }
          } catch (e) {
            x = y = z = NaN;
          }
          points.push(x, y, z);
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));

      if (mode === 'surface') {
        const indices = [];
        for (let i = 0; i < countX - 1; i++) {
          for (let j = 0; j < countY - 1; j++) {
            const a = i * countY + j;
            const b = a + 1;
            const c = a + countY;
            const d = c + 1;
            indices.push(a, b, d, a, d, c);
          }
        }
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        let material;
        if (lightMode === 'wireframe') {
          material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
        } else {
          const texLoader = new THREE.TextureLoader();
          const texture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
          material = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            map: texture,
            metalness: 0.5,
            roughness: lightMode === 'soft' ? 0.9 : 0.3,
            flatShading: lightMode === 'strong',
            side: THREE.DoubleSide,
          });
        }
        surfaceMesh = new THREE.Mesh(geometry, material);
      } else {
        const group = new THREE.Group();
        for (let i = 0; i < countX; i++) {
          const linePoints = [];
          for (let j = 0; j < countY; j++) {
            const idx = i * countY + j;
            linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
          }
          const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
          group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffff00 })));
        }
        for (let j = 0; j < countY; j++) {
          const linePoints = [];
          for (let i = 0; i < countX; i++) {
            const idx = i * countY + j;
            linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
          }
          const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
          group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffaa00 })));
        }
        surfaceMesh = group;
      }
      scene.add(surfaceMesh);
      addToHistory(`B·ªÅ m·∫∑t: ${formulaRaw}`, surfaceMesh);

    }

    function plotPrimitive() {
      const choice = document.getElementById("primitiveShape").value;
      let mesh;
      const material = new THREE.MeshStandardMaterial({ color: 0x33ffff });

      switch (choice) {
        case 'cube':
          mesh = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), material);
          break;
        case 'sphere':
          mesh = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), material);
          break;
        case 'cylinder':
          mesh = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 15, 32), material);
          break;
        case 'cone':
          mesh = new THREE.Mesh(new THREE.ConeGeometry(5, 15, 32), material);
          break;
        case 'circle':
          mesh = new THREE.Mesh(new THREE.CircleGeometry(8, 32), material);
          break;
        case 'ellipse':
          const ellipse = new THREE.Shape();
          ellipse.absellipse(0, 0, 8, 4, 0, Math.PI * 2, false, 0);
          const ellipseGeom = new THREE.ShapeGeometry(ellipse);
          mesh = new THREE.Mesh(ellipseGeom, material);
          break;
        case 'triangle':
          const triShape = new THREE.Shape();
          triShape.moveTo(0, 10);
          triShape.lineTo(-8.66, -5);
          triShape.lineTo(8.66, -5);
          triShape.lineTo(0, 10);
          const triGeom = new THREE.ShapeGeometry(triShape);
          mesh = new THREE.Mesh(triGeom, material);
          break;
        case 'pentagon':
          mesh = polygonMesh(5, 6, material);
          break;
        case 'hexagon':
          mesh = polygonMesh(6, 6, material);
          break;
        case 'pyramid':
          const geom = new THREE.ConeGeometry(7, 10, 4);
          mesh = new THREE.Mesh(geom, material);
          break;
        case 'plane':
          mesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), material);
          break;
        default:
          alert("H√£y ch·ªçn kh·ªëi h√¨nh.");
          return;
      }

      mesh.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, Math.random() * 20 - 10);
      scene.add(mesh);

    }
    let customCurve; // l∆∞u ƒë∆∞·ªùng c≈© ƒë·ªÉ x√≥a tr∆∞·ªõc khi v·∫Ω m·ªõi

    function plotCustom3D() {
      const tMin = parseFloat(document.getElementById("tMin").value);
      const tMax = parseFloat(document.getElementById("tMax").value);
      const res = parseInt(document.getElementById("tRes").value);

      const rawX = document.getElementById("customX").value.trim().toLowerCase();
      const rawY = document.getElementById("customY").value.trim().toLowerCase();
      const rawZ = document.getElementById("customZ").value.trim().toLowerCase();

      if (!rawX.startsWith("x = ") || !rawY.startsWith("y = ") || !rawZ.startsWith("z = ")) {
        alert("Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng: x = ..., y = ..., z = ...");
        return;
      }

      const xExpr = rawX.split("=")[1];
      const yExpr = rawY.split("=")[1];
      const zExpr = rawZ.split("=")[1];

      let fx, fy, fz;
      try {
        fx = math.compile(xExpr);
        fy = math.compile(yExpr);
        fz = math.compile(zExpr);
      } catch (e) {
        alert("L·ªói trong c√¥ng th·ª©c: " + e.message);
        return;
      }

      // Xo√° ƒë∆∞·ªùng cong c≈© n·∫øu c√≥
      if (customCurve) scene.remove(customCurve);

      const points = [];
      for (let i = 0; i <= res; i++) {
        const t = tMin + ((tMax - tMin) * i / res);

        const context = {
          t: t,
          theta: t,
          u: t,
          v: t
        };

        try {
          const x = fx.evaluate(context);
          const y = fy.evaluate(context);
          const z = fz.evaluate(context);

          if (isFinite(x) && isFinite(y) && isFinite(z)) {
            points.push(new THREE.Vector3(x, y, z));
          }
        } catch (e) {
          console.warn("L·ªói khi ƒë√°nh gi√° t·∫°i t =", t, ":", e.message);
        }
      }

      if (points.length < 2) {
        alert("Kh√¥ng ƒë·ªß ƒëi·ªÉm h·ª£p l·ªá ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng.");
        return;
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0xff44aa });
      customCurve = new THREE.Line(geometry, material);
      scene.add(customCurve);
      addToHistory(`T√πy ch·ªânh 3D`, customCurve);

    }

    // H√†m h·ªó tr·ª£ t·∫°o ƒëa gi√°c 2D ƒë·ªÅu (pentagon, hexagon,...)
    function polygonMesh(sides, radius, material) {
      const shape = new THREE.Shape();
      for (let i = 0; i <= sides; i++) {
        const angle = (i / sides) * Math.PI * 2;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        if (i === 0) shape.moveTo(x, y);
        else shape.lineTo(x, y);
      }
      const geometry = new THREE.ShapeGeometry(shape);
      return new THREE.Mesh(geometry, material);
    }


    // V·∫Ω ƒë·ªì th·ªã c·ª±c
    function plotPolar() {
      const formula = document.getElementById("polarFormula").value;
      const expr = math.compile(formula);
      const points = [];

      for (let i = 0; i <= 1000; i++) {
        const theta = (i / 1000) * Math.PI * 2;
        let r = 0;
        try { r = expr.evaluate({ theta }); } catch (e) { }
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        points.push(new THREE.Vector3(x, 0, y));
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const polarCurve = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff9933 }));
      scene.add(polarCurve);
      addToHistory(`ƒê·ªì th·ªã c·ª±c: ${formula}`, polarCurve);

    }
    const historyList = document.getElementById('historyList');

    function addToHistory(label, object3D) {
      const li = document.createElement('li');
      li.classList.add('flex', 'justify-between', 'items-center');

      const span = document.createElement('span');
      span.textContent = label;
      span.classList.add('cursor-pointer', 'hover:text-yellow-300', 'truncate');

      let visible = true;
      span.addEventListener('click', () => {
        visible = !visible;
        object3D.visible = visible;
        span.style.textDecoration = visible ? 'none' : 'line-through';
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'üóë';
      deleteBtn.classList.add('ml-2', 'hover:text-red-500');
      deleteBtn.addEventListener('click', () => {
        scene.remove(object3D);      // Xo√° kh·ªèi scene
        li.remove();                // Xo√° kh·ªèi giao di·ªán l·ªãch s·ª≠
      });

      li.appendChild(span);
      li.appendChild(deleteBtn);
      historyList.appendChild(li);
    }

    function updateLightMode() {
      const mode = document.getElementById("lightMode").value;

      if (!surfaceMesh) return; // ch∆∞a c√≥ g√¨ ƒë·ªÉ c·∫≠p nh·∫≠t

      let newMaterial;
      if (mode === 'wireframe') {
        newMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
      } else {
        const texLoader = new THREE.TextureLoader();
        const texture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
        newMaterial = new THREE.MeshStandardMaterial({
          color: 0x00ffff,
          map: texture,
          metalness: 0.5,
          roughness: mode === 'soft' ? 0.9 : 0.3,
          flatShading: mode === 'strong',
          side: THREE.DoubleSide,
        });
      }

      // G√°n l·∫°i v·∫≠t li·ªáu cho b·ªÅ m·∫∑t hi·ªán t·∫°i
      if (surfaceMesh instanceof THREE.Mesh) {
        surfaceMesh.material.dispose();
        surfaceMesh.material = newMaterial;
      }
    }

    // Xu·∫•t ·∫£nh
    function saveImage() {
      renderer.render(scene, camera);
      const link = document.createElement('a');
      link.download = 'screenshot.png';
      link.href = renderer.domElement.toDataURL('image/png');
      link.click();
    }
    function toggleMiniForm() {
      const form = document.getElementById('miniForm');
      form.classList.toggle('hidden');
    }
    // Auto rotate toggle
    let autoRotate = true;
    document.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'r') autoRotate = !autoRotate;
    });

    function animate() {
      requestAnimationFrame(animate);
      if (autoRotate) scene.rotation.y += 0.003;
      controls.update();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });
    let is2DMode = false;
    let previousCameraPos = new THREE.Vector3(); // L∆∞u camera c≈©
    let previousTarget = new THREE.Vector3();    // L∆∞u target c≈© n·∫øu d√πng controls.target

    function toggle2DMode() {
      is2DMode = document.getElementById("toggle2D").checked;

      if (is2DMode) {
        // L∆∞u v·ªã tr√≠ camera v√† target tr∆∞·ªõc ƒë√≥
        previousCameraPos.copy(camera.position);
        previousTarget.copy(controls.target);

        // ƒê·∫∑t camera nh√¨n t·ª´ tr√™n xu·ªëng
        camera.position.set(0, 100, 0);
        controls.target.set(0, 0, 0);
        camera.lookAt(0, 0, 0);

        // Kh√≥a xoay camera
        controls.enableRotate = false;

        // T·∫Øt xoay t·ª± ƒë·ªông n·∫øu d√πng autoRotate
        autoRotate = false;

        // ·∫®n tr·ª•c Z v√† nh√£n Z
        if (zAxis) zAxis.visible = false;
        if (zLabel) zLabel.visible = false;

        // ·∫®n line ho·∫∑c c√°c ƒë·ªëi t∆∞·ª£ng n·∫øu c·∫ßn
        if (line) line.visible = false;

        // Xoay scene v·ªÅ g√≥c chu·∫©n
        scene.rotation.set(0, 0, 0);
      } else {
        // Kh√¥i ph·ª•c l·∫°i v·ªã tr√≠ camera v√† target
        camera.position.copy(previousCameraPos);
        controls.target.copy(previousTarget);
        camera.lookAt(previousTarget);

        // M·ªü l·∫°i xoay
        controls.enableRotate = true;

        // B·∫≠t l·∫°i autoRotate n·∫øu d√πng
        autoRotate = true;

        // Hi·ªán l·∫°i tr·ª•c Z v√† nh√£n Z
        if (zAxis) zAxis.visible = true;
        if (zLabel) zLabel.visible = true;

        // Hi·ªán l·∫°i line n·∫øu c√≥
        if (line) line.visible = true;
      }

      controls.update();
    }

    function toggleDiv(id) {
      const el = document.getElementById(id);
      if (el) {
        el.classList.toggle('hidden');
      }
    }


    function toggleMenu() {
      const menu = document.getElementById('floatingMenu');
      menu.classList.toggle('hidden');
    }

    function toggleDiv(id) {
      const el = document.getElementById(id);
      if (el) el.classList.toggle('hidden');
    }

  </script>
</body>

</html>